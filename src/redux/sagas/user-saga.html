<script>
    (function () {
        // Items initialized in setup.html
        const {
            web3Local,
            web3s,
            ipfs,
            ReduxSaga,
            contractsData,
            contracts
        } = window;
        // ReduxSaga methods
        const { effects, eventChannel, delay } = ReduxSaga;
        const { call, fork, take, put, takeEvery, all } = effects;

        // Import contract data:
        const { swtToken, hashtagList, simpleDeal } = contractsData;

        /*
         * Selector functions
         */
        const getFirebaseApp = (state) => state.firebaseApp;
        const getUser = (state) => state.user;

        /*
         * redux-saga worker functions
         */


        // worker Saga: will be fired on LOAD_LIST actions
        function createTxsChannel(address) {
            return eventChannel(emitter => {
                const swtContractInstance = new web3Local.eth.Contract(
                    kovSwtToken.abi,
                    kovSwtToken.address
                );
                swtContractInstance.events.Transfer({
                    filter: { _to: address },
                }, function (error, event) {
                    emitter(event)
                })
                swtContractInstance.events.Transfer({
                    filter: { _from: address },
                }, function (error, event) {
                    emitter(event)
                })

        const createTxsChannel = (address, chain) => eventChannel(emitter => {
            let tokenData
            try {
                if (!web3s[chain]) throw Error(`Requested tx sub of unsupported chain: ${chain}`)
                if (!chain) throw Error('chain is not defined')
                if (!contracts.token[chain]) throw Error('Unknown chain: ' + chain)

                tokenData = ((contracts || {}).token || {})[chain] || {}
                if (tokenData.abi.length === 0) throw Error(`Empty ABI for token address ${address} chain ${chain}`)
                const token = new web3s[chain].eth.Contract(
                    tokenData.abi,
                    tokenData.address
                );
                const handler = (err, event) => {
                    if (err) console.error(`Error receiving ${chain} token Transfer event`, err)
                    else emitter(event)
                }
                if (token && token.events && token.events.Transfer) {
                    token.events.Transfer({ filter: { _to: address } }, handler)
                    token.events.Transfer({ filter: { _from: address } }, handler)
                } else {
                    console.log({ token, events: token.events })
                    throw Error('Transfer event not supported: ', { token, events: token.events })
                }
            } catch (e) {
                console.error(`Error creating subscription to ${chain} token contract ${(tokenData || {}).address}`, e)
            }

            // The subscriber must return an unsubscribe function
            return () => {
                // No unsubscribe function for now
            }
        })

        function* txsSubscription(address, chain) {
            const txsChannel = yield call(createTxsChannel, address, chain)
            try {
                while (true) {
                    const event = yield take(txsChannel)
                    const events = [event]
                    const txs = handleTransferEvents(events, address, chain)
                    yield put({ type: 'UPDATE_TXS', chain, txs });
                    console.log('Received tx', chain, txs)
                    // Re-fetch balance
                    yield fork(getBalance, { address, chain })
                    // take(END) will cause the saga to terminate by jumping to the finally block
                }
            } finally {
                console.log('countdown terminated')
            }
        }

        async function createLogsForDirection(address, chain) {
            if (!web3s[chain]) console.error(`Requested tx logs of unsupported chain: ${chain}`)
            const tokenData = ((contracts || {}).token || {})[chain] || {}
            const token = new web3s[chain].eth.Contract(
                tokenData.abi,
                tokenData.address
            );
            // Fetch transactions
            const [incoming, outgoing] = await Promise.all(['_to', '_from'].map(direction =>
                token.getPastEvents('Transfer', {
                    fromBlock: contracts.token[chain].deployedBlockNumber,
                    filter: { [direction]: address }
                })
            ))
            // Merge transactions
            const events = [...incoming, ...outgoing]
            return handleTransferEvents(events, address, chain)
        }

        async function handleTransferEvents(events, address, chain) {
            const getTimestamps = (blockNumber) => web3s[chain].eth.getBlock(blockNumber)
                .then(block => block.timestamp)
                .catch(e => console.error('Error fetching datetime of block ' + blockNumber))

            const txs = {}
            // Keep only the relevant data
            await Promise.all(events.map(async event => {
                txs[event.transactionHash] = {
                    transactionHash: event.transactionHash,
                    to: event.returnValues._to,
                    from: event.returnValues._from,
                    amount: event.returnValues._amount,
                    // Mark outgoing as so. For incoming, tx.outgoing is false
                    outgoing: event.returnValues._from === address,
                    blockNumber: event.blockNumber,
                    // Fetch the time of the transaction, and assign it to the tx object
                    timestamp: await getTimestamps(event.blockNumber)
                }
            }))
            // Return the result
            return txs
        }

        function* getTxs({ address, chain }) {
            try {
                if (!chain) throw Error('chain is not defined')

                yield fork(txsSubscription, address, chain)

                const txs = yield call(createLogsForDirection, address, chain)
                yield put({ type: 'UPDATE_TXS', chain, txs });

                // The code below is left as example / reference to add loaders during fetch

                // let result = [1, 2, 3, 4, 5];
                // yield put(MyApp.actions.setLoadedList(result));
                // yield put(MyApp.actions.showSpinner(false));
                // yield put(MyApp.actions.showInfo('List loaded'));
            } catch (e) {
                console.error(e);
                // yield put(MyApp.actions.showError('Error while fetching list', e));
                // yield put(MyApp.actions.clearLoadedList());
                // yield put(MyApp.actions.showSpinner(false));
            }
        }

        async function getTokenBalance(address, chain) {
            if (!web3s[chain]) console.error(`Requested balance of unsupported chain: ${chain}`)
            const tokenData = ((contracts || {}).token || {})[chain] || {}
            const token = new web3s[chain].eth.Contract(
                tokenData.abi,
                tokenData.address
            );
            const balance = await token.methods.balanceOf(address).call()
            
            // Check for kovan eth balance, trigger faucet if less than 0.1 eth
//             if (address) {
//                 const ethBalance = await web3Local.eth.getBalance(address);

//                 if (ethBalance < 50000000000000000) {
//                     console.log('Asking faucet for a refill, ethbalance: ', ethBalance)
//                     var xhr = new XMLHttpRequest();
//                         xhr.open('GET', 'http://165.227.33.81:33333/donate/' + address);
//                         xhr.send(null);
//                 }
//             }
            
//             const kovanSwtContractInstance = new web3Local.eth.Contract(
//                 kovSwtToken.abi,
//                 kovSwtToken.address
//             );

//             const kovan = await kovanSwtContractInstance.methods.balanceOf(address).call()
//             return {kovan};
          
            return balance
        }

        function* getBalance({ address, chain }) {
            try {
                const balance = yield call(getTokenBalance, address, chain)
                yield put({ type: 'UPDATE_BALANCE', chain, balance });
            } catch (e) {
                console.error(e);
            }
        }

        function* getBalanceWrap({ address, chain }) {
            try {
                if (chain) yield call(getBalance, { address, chain })
                else yield all(['mainnet', 'kovan'].map(_chain =>
                    call(getBalance, { address, chain: _chain })))
            } catch (e) {
                console.error('Error on getBalanceWrap', e);
            }
        }

        function* getTxsWrap({ address, chain }) {
            try {
                if (chain) yield call(getTxs, { address, chain })
                else yield all(['mainnet', 'kovan'].map(_chain =>
                    call(getTxs, { address, chain: _chain })))
            } catch (e) {
                console.error('Error on getTxsWrap', e);
            }
        }

        /*
         * redux-saga root function, which is responsible to call the correct workers
         */


        function* rootSaga() {
            yield all([
                yield takeEvery('GET_BALANCE', getBalanceWrap),
                yield takeEvery('GET_TXS', getTxsWrap),
            ]);
        }

        if (!window.AppStore) window.AppStore = {}
        if (!window.AppStore.sagas) window.AppStore.sagas = []
        window.AppStore.sagas.push(rootSaga)
    }());
</script>