<script>
    (function () {
        // Items initialized in setup.html
        const {
            web3Local,
            web3s,
            ipfs,
            ReduxSaga,
            contractsData,
            contracts
        } = window;
        // ReduxSaga methods
        const { effects, eventChannel, delay } = ReduxSaga;
        const { call, fork, take, put, takeEvery, all } = effects;

        // Import contract data:
        const { swtToken, hashtagList, simpleDeal } = contractsData;

        /*
         * Selector functions
         */
        const getFirebaseApp = (state) => state.firebaseApp;
        const getUser = (state) => state.user;

        /*
         * redux-saga worker functions
         */


        // worker Saga: will be fired on LOAD_LIST actions

        const createTxsChannel = (address, chain) => eventChannel(emitter => {
            try {
                const token = new web3s[chain].eth.Contract(
                    contracts.token[chain].abi,
                    contracts.token[chain].address
                );
                ['_to', '_from'].forEach(direction => {
                    token.events.Transfer({ filter: { [direction]: address } }, (err, event) => {
                        if (err) console.error(`Error receiving ${chain} token Transfer event`, err)
                        else emitter(event)
                    })
                })
            } catch (e) {
                console.error(`Error creating subscription to ${chain} token contract ${swtContractInstance._address}`, e)
            }

            // The subscriber must return an unsubscribe function
            return () => {
                // No unsubscribe function for now
            }
        })

        function* txsSubscription(address, chain) {
            const txsChannel = yield call(createTxsChannel, address, chain)
            try {
                while (true) {
                    const event = yield take(txsChannel)
                    const events = [event]
                    const txs = handleTransferEvents(events, address, chain)
                    yield put({ type: 'UPDATE_TXS', chain, txs });
                    console.log('Received tx', chain, txs)
                    // Re-fetch balance
                    yield fork(getBalance, { address, chain })
                    // take(END) will cause the saga to terminate by jumping to the finally block
                }
            } finally {
                console.log('countdown terminated')
            }
        }

        async function createLogsForDirection(address, chain) {
            const token = new web3s[chain].eth.Contract(
                contracts.token[chain].abi,
                contracts.token[chain].address
            );
            // Fetch transactions
            const [incoming, outgoing] = await Promise.all(['_to', '_from'].map(direction =>
                token.getPastEvents('Transfer', {
                    fromBlock: contracts.token[chain].deployedBlockNumber,
                    filter: { [direction]: address }
                })
            ))
            // Merge transactions
            const events = [...incoming, ...outgoing]
            return handleTransferEvents(events, address, chain)
        }

        async function handleTransferEvents(events, address, chain) {
            const getTimestamps = (blockNumber) => web3s[chain].getBlock(blockNumber)
                .then(block => block.timestamp)
                .catch(e => console.error('Error fetching datetime of block ' + blockNumber))

            const txs = {}
            // Keep only the relevant data
            await Promise.all(events.map(async event => {
                txs[event.transactionHash] = {
                    transactionHash: event.transactionHash,
                    to: event.returnValues._to,
                    from: event.returnValues._from,
                    amount: event.returnValues._amount,
                    // Mark outgoing as so. For incoming, tx.outgoing is false
                    outgoing: event.returnValues._from === address,
                    blockNumber: event.blockNumber,
                    // Fetch the time of the transaction, and assign it to the tx object
                    timestamp: await getTimestamps(event.blockNumber)
                }
            }))
            // Return the result
            return txs
        }

        function* getTxs({ address, chain }) {
            try {
                yield fork(txsSubscription, address, chain)

                const txs = yield call(createLogsForDirection, address, chain)
                yield put({ type: 'UPDATE_TXS', chain, txs });
                console.log('Received txs', chain, txs)

                // The code below is left as example / reference to add loaders during fetch

                // let result = [1, 2, 3, 4, 5];
                // yield put(MyApp.actions.setLoadedList(result));
                // yield put(MyApp.actions.showSpinner(false));
                // yield put(MyApp.actions.showInfo('List loaded'));
            } catch (e) {
                console.error(e);
                // yield put(MyApp.actions.showError('Error while fetching list', e));
                // yield put(MyApp.actions.clearLoadedList());
                // yield put(MyApp.actions.showSpinner(false));
            }
        }

        async function getTokenBalance(address, chain) {
            let _web3;
            if (chain === 'mainnet') _web3 = web3Mainnet;
            else if (chain === 'kovan') _web3 = web3Kovan;
            else console.error(`Requested balance of unsupported chain: ${chain}`)
            const swtContractInstance = new _web3.eth.Contract(
                erc20TokenAbiBalance,
                swtToken.address
            );
            const balance = await swtContractInstance.methods.balanceOf(address).call()
            return balance
        }

        function* getBalance({ address, chain }) {
            try {
                const balance = yield call(getTokenBalance, address, chain)
                yield put({ type: 'UPDATE_BALANCE', chain, balance });
            } catch (e) {
                console.error(e);
            }
        }

        function* getBalanceWrap({ address, chain }) {
            try {
                if (chain) {
                    yield call(getBalance, { address, chain })
                } else {
                    yield all(['mainnet', 'kovan'].map(_chain =>
                        call(getBalance, { address, chain: _chain })))
                }
            } catch (e) {
                console.error('Error on getBalanceWrap', e);
            }
        }

        function* getTxsWrap({ address, chain }) {
            try {
                if (chain) {
                    yield call(getTxs, { address, chain })
                } else {
                    yield all(['mainnet', 'kovan'].map(_chain =>
                        call(getTxs, { address, chain: _chain })))
                }
            } catch (e) {
                console.error('Error on getTxsWrap', e);
            }
        }

        /*
         * redux-saga root function, which is responsible to call the correct workers
         */


        function* rootSaga() {
            yield all([
                yield takeEvery('GET_BALANCE', getBalanceWrap),
                yield takeEvery('GET_TXS', getTxs),
            ]);
        }

        if (!window.AppStore) window.AppStore = {}
        if (!window.AppStore.sagas) window.AppStore.sagas = []
        window.AppStore.sagas.push(rootSaga)
    }());
</script>