<script>
    (function () {
        // Items initialized in setup.html
        const { web3Mainnet, web3Local, ipfs, ReduxSaga, contractsData } = window;
        // ReduxSaga methods
        const { effects, eventChannel, delay } = ReduxSaga;
        const { call, fork, take, put, takeEvery, all } = effects;

        // Import contract data:
        const { mainSwtToken, kovSwtToken, hashtagList, simpleDeal } = contractsData;

        /*
         * Selector functions
         */
        const getFirebaseApp = (state) => state.firebaseApp;
        const getUser = (state) => state.user;

        /*
         * redux-saga worker functions
         */



        // worker Saga: will be fired on LOAD_LIST actions
        function createTxsChannel(address) {
            return eventChannel(emitter => {
                const swtContractInstance = new web3Local.eth.Contract(
                    kovSwtToken.abi,
                    kovSwtToken.address
                );
                swtContractInstance.events.Transfer({
                    filter: { _to: address },
                }, function (error, event) {
                    emitter(event)
                })
                swtContractInstance.events.Transfer({
                    filter: { _from: address },
                }, function (error, event) {
                    emitter(event)
                })

                // The subscriber must return an unsubscribe function
                return () => {
                    // No unsubscribe function for now
                }
            }
            )
        }

        function* saga() {
            const txsChannel = yield call(createTxsChannel, address)
            try {
                while (true) {
                    // take(END) will cause the saga to terminate by jumping to the finally block
                    let event = yield take(txsChannel)
                    console.log('Received event', event)
                }
            } finally {
                console.log('countdown terminated')
            }
        }


        async function createLogsForDirection(address) {
            const swtContractInstance = new web3Local.eth.Contract(
                kovSwtToken.abi,
                kovSwtToken.address
            );
            // Fetch transactions
            const [incoming, outgoing] = await Promise.all([
                swtContractInstance.getPastEvents('Transfer', {
                    'fromBlock': kovSwtToken.creationBlock,
                    'filter': { _to: address },
                }),
                swtContractInstance.getPastEvents('Transfer', {
                    'fromBlock': kovSwtToken.creationBlock,
                    'filter': { _from: address },
                })
            ])
            // Merge transactions, mark outgoing as so. For incoming, tx.outgoing is false
            // Keep only the relevant data
            const txs = [...incoming, ...outgoing].map(tx => ({
                transactionHash: tx.transactionHash,
                to: tx.returnValues._to,
                from: tx.returnValues._from,
                amount: tx.returnValues._amount,
                outgoing: tx.returnValues._from === address,
                blockNumber: tx.blockNumber
            }))
            // Fetch the time of the transaction, and assign it to the tx object
            await Promise.all(txs.map(tx =>
                web3Local.eth.getBlock(tx.blockNumber)
                    .then(block => tx.timestamp = block.timestamp)
                    .catch(e => console.error('Error fetching datetime of block ' + tx.blockNumber))
            ))
            // Return the result
            return txs
        }
        function* getTxs(action) {
            try {
                const txs = yield call(createLogsForDirection, action.address)
                yield put(AppStore.actions.updateTxs(txs));
                console.log('Received txs', txs)

                // The code below is left as example / reference to add loaders during fetch

                // let result = [1, 2, 3, 4, 5];
                // // Artificial to delay to simulate a REST call like behavior
                // yield ReduxSaga.delay(1000);
                // yield put(MyApp.actions.setLoadedList(result));
                // yield put(MyApp.actions.showSpinner(false));
                // yield put(MyApp.actions.showInfo('List loaded'));
            } catch (e) {
                console.error(e);
                // yield put(MyApp.actions.showError('Error while fetching list', e));
                // yield put(MyApp.actions.clearLoadedList());
                // yield put(MyApp.actions.showSpinner(false));
            }
        }

        async function getTokenBalances(address) {
            const kovanSwtContractInstance = new web3Local.eth.Contract(
                kovSwtToken.abi,
                kovSwtToken.address
            );

            const mainSwtContractInstance = new web3Mainnet.eth.Contract(
                mainSwtToken.abi,
                mainSwtToken.address
            );

            const kovan = await kovanSwtContractInstance.methods.balanceOf(address).call()
            const main = await mainSwtContractInstance.methods.balanceOf(address).call()

            return {main, kovan};
        }

        function* getBalance(action) {
            try {
                const balance = yield call(getTokenBalances, action.address)
                yield put({ type: 'UPDATE_BALANCE', balance });
            } catch (e) {
                console.error(e);
            }
        }


        /*
         * redux-saga root function, which is responsible to call the correct workers
         */


        function* rootSaga() {
            yield all([
                yield takeEvery('GET_BALANCE', getBalance),
                yield takeEvery('GET_TXS', getTxs),
            ]);
        }

        if (!window.AppStore) window.AppStore = {}
        if (!window.AppStore.sagas) window.AppStore.sagas = []
        window.AppStore.sagas.push(rootSaga)
    }());
</script>