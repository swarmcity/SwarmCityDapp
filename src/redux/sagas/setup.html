<script src="../../../node_modules/redux-saga/dist/redux-saga.js"></script>
<script src="../../../node_modules/ethjs/dist/ethjs.min.js"></script>
<script src="../../../node_modules/ipfs-api/dist/index.min.js"></script>
<script src="./bs58.js"></script>
<script src="./Buffer.js"></script>
<script src="../../web3/web3.min.js"></script>
<script src="../contractsData.js"></script>

<script>
    (function () {
        /**
         * Setup web3 instances
         */
        const selectedProvider = 'infura'
        const web3Providers = {
            infura: {
                mainnet: 'wss://mainnet.infura.io/ws',
                kovan: 'wss://kovan.infura.io/ws'
            },
            dappnode: {
                mainnet: 'ws://my.ethchain.dnp.dappnode.eth:8546',
                kovan: 'ws://my.kovan.dnp.dappnode.eth:8546'
            }
        }
        window.web3s = {
            mainnet: new Web3(web3Providers[selectedProvider].mainnet),
            kovan: new Web3(web3Providers[selectedProvider].kovan)
        }
        window.web3Mainnet = web3s.mainnet
        window.web3Kovan = web3s.kovan
        window.web3Local = window.web3Kovan
        console.log('Redux-sagas is using web3Local version: ', web3Local.version,'host: ', web3Local.currentProvider)

        /**
         * Contract addresses
         */
         const contracts = {
            production: {
                bridge: {
                    mainnet: {
                        address: '0x3410349F1e02E3beab54b1513FC2C9D2bAb6D7aC' // FOREIGN_BRIDGE_ADDRESS
                    },
                    kovan: {
                        address: '0xFeAf593f51A53efA8523E5baA8f0EBDc6B2deB69' // HOME_BRIDGE_ADDRESS
                    }
                },
                token: {
                    mainnet: {
                        address: '0xB9e7F8568e08d5659f5D29C4997173d84CdF2607', // ERC20_TOKEN_ADDRESS
                        deployedBlockNumber: 3055641,
                        abi: [...contractAbis.erc20TokenBalance, ...contractAbis.erc20TokenTransfer]
                    },
                    kovan: {
                        address: '0x68b4bFF76B06FF72767ac1989Ea9706Bbc26Da4c', // BRIDGEABLE_TOKEN_ADDRESS
                        deployedBlockNumber: 8420473,
                        abi: [...contractAbis.erc20TokenBalance, ...contractAbis.erc677TokenTransferAndCall]
                    }
                },
                hashtagDir: {
                    address: '0xbde0a0218b87f138a4f421d5c75e71e19af9bc50'
                }
            },
            development: {
                bridge: {
                    mainnet: {
                        address: null // No bridge
                    },
                    kovan: {
                        address: null // No bridge
                    }
                },
                token: {
                    mainnet: {
                        address: null, // ERC20_TOKEN_ADDRESS
                        deployedBlockNumber: 0,
                        abi: []
                    },
                    kovan: {
                        address: '0x0adbc89464cb7fa752adcf3533514949a2547589', // Old test SWT token
                        deployedBlockNumber: 7288019,
                        abi: []
                    }
                },
                hashtagDir: {
                    address: '0xbde0a0218b87f138a4f421d5c75e71e19af9bc50'
                }
            },
        }
        window.contracts = contracts['development']

        /*
         * Setup IPFS with a simple retry async flow. 
         * It will attempt each function 3 times before returning the error
         * 
        **/
        const ipfs = IpfsApi('localhost', '5001', { protocol: 'http' })
        console.log('Redux-sagas is using ipfs at http://localhost:5001')

        const retryable = (fn, times = 3) => (...args) => new Promise((resolve, reject) => {
            let attempt = 0
            function retryAttempt() {
                fn(...args).then(
                    resolve,
                    e => {
                        if (e && attempt++ < times) setTimeout(retryAttempt, 1000 * Math.random())
                        else reject(e)
                    }
                )
            }
            retryAttempt()
        })

        // Dependencies:
        const bs58 = window.bs58
        const Buffer = window.buffer.Buffer

        // Return bytes32 hex string from base58 encoded ipfs hash,
        // stripping leading 2 bytes from 34 byte IPFS hash
        // Assume IPFS defaults: function:0x12=sha2, size:0x20=256 bits
        // E.g. "QmNSUYVKDSvPUnRLKmuxk9diJ6yS96r1TrAXzjTiBcCLAL" -->
        // "0x017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f231"

        function hashToBytes32(hash) {
            if (!hash) return
            if (!hash.startsWith('Qm')) {
                throw Error('Hash must use sha2-256 hashAlg, and start with \'Qm\'')
            }
            return "0x" + bs58.decode(hash).slice(2).toString('hex')
        }

        // Return base58 encoded ipfs hash from bytes32 hex string,
        // Add our default ipfs values for first 2 bytes:
        // function:0x12=sha2, size:0x20=256 bits
        // and cut off leading "0x"
        // E.g. "0x017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f231"
        // --> "QmNSUYVKDSvPUnRLKmuxk9diJ6yS96r1TrAXzjTiBcCLAL"

        function bytes32ToHash(bytes32) {
            if (!bytes32) {
                throw Error('In ipfs.bytes32ToHash, hash or bytes32 is not defined')
            }
            const hashHex = "1220" + bytes32.slice(2)
            const hashBytes = Buffer.from(hashHex, 'hex');
            const hashStr = bs58.encode(hashBytes)
            return hashStr
        }

        function ipfsAdd(data) {
            if (!Buffer.isBuffer(data)) {
                data = Buffer.from(data, 'utf8')
            }
            return ipfs.add(data, { hashAlg: 'sha2-256' }).then(res => ({
                hash: res[0].hash,
                bytes32: hashToBytes32(res[0].hash)
            }))
        }

        function ipfsCat(hash) {
            if (hash && !hash.startsWith('Qm')) {
                // Assuming hash is actually a bytes32
                hash = bytes32ToHash(hash)
            }
            return ipfs.cat(hash).then(file => file.toString('utf8'))
        }

        window.ipfs = {
            add: retryable(ipfsAdd),
            cat: retryable(ipfsCat)
        }

        window.bs58 = {
            bytes32ToHash,
            hashToBytes32
        }

        // Import contract data:
        // const { kovSwtToken, hashtagList, simpleDeal } = window.contractsData;

    }());
</script>