<script src="../../../node_modules/redux-saga/dist/redux-saga.js"></script>
<script src="../../../node_modules/ethjs/dist/ethjs.min.js"></script>
<script src="../../../node_modules/ipfs-api/dist/index.min.js"></script>
<script src="./Buffer.js"></script>
<script src="./cids.min.js"></script>
<script src="../../web3/web3.min.js"></script>
<script src="../contractsData.js"></script>

<script>
    (function () {
        // Initialize web3Local
        const url = 'wss://kovan.infura.io/ws   '
        // const url = 'ws://159.100.255.71:8546'
        // const url = 'ws://my.kovan.dnp.dappnode.eth:8546'
        window.web3Local = new Web3(url);
        window.web3Mainnet = new Web3('wss://mainnet.infura.io/ws');

        // 159.100.255.71:8546 or 8645

        console.log('Redux-sagas is using web3Local version: ', web3Local.version,'host: ', web3Local.currentProvider)
        console.log('Redux-sagas is using web3Mainnet version: ', web3Mainnet.version,'host: ', web3Mainnet.currentProvider)

        /*
         * Setup IPFS with a simple retry async flow. 
         * It will attempt each function 3 times before returning the error
         * 
        **/
        const ipfs = IpfsApi('localhost', '5001', { protocol: 'http' })
        console.log('Redux-sagas is using ipfs at http://localhost:5001')

        const retryable = (fn, times = 3) => (...args) => new Promise((resolve, reject) => {
            let attempt = 0
            function retryAttempt() {
                fn(...args).then(
                    resolve,
                    e => {
                        if (e && attempt++ < times) setTimeout(retryAttempt, 1000 * Math.random())
                        else reject(e)
                    }
                )
            }
            retryAttempt()
        })

        // Dependencies:
        const Buffer = window.buffer.Buffer
        const CID = window.CID

        // Return bytes32 hex string from base58 encoded ipfs hash,
        // Enforces that the encoding is SHA-256 32 bytes
        // Supports CIDv0 and CIDv1
        // |----------CID v1-----------------------------------------------------------------------------------------|
        //       |----CID v0-----------------------------------------------------------------------------------------|
        // 01 55 12 20 b1 02 74 3d b0 6d ab 56 5f a8 73 fc 41 28 13 90 02 34 1b 80 e2 24 f9 b8 de f7 d7 a4 e4 32 eb 10
        // |  |  |  |  | Hash of the data (the rest of bytes)
        // |  |  |  | Length of the hash
        // |  |  | Hashing algorithm
        // |  | 
        // |
        // 
        // Will return the hash of the data only in hex prepended by 0x
        function hashToBytes32(hash) {
            const cid = new CID(hash)
            const hashId = cid.multihash.slice(0, 2).toString('hex')
            const bytes32 = cid.multihash.slice(2).toString('hex')
            if (hashId !== '1220' || bytes32.length / 2 !== 32) {
                console.error(`IPFS hash is not SHA-256 32 bytes: ${hashId} !== "1220"`)
            } else {
                return "0x" + bytes32
            }
        }

        // Return base58 encoded ipfs hash from bytes32 hex string,
        // Assumes the hashing options are: SHA-256 32 bytes (1220)
        // Strips leading "0x" if necessary
        // E.g. "0x017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f231"
        // --> "QmNSUYVKDSvPUnRLKmuxk9diJ6yS96r1TrAXzjTiBcCLAL"

        function bytes32ToHash(bytes32) {
            if (!bytes32) {
                throw Error('In ipfs.bytes32ToHash, hash or bytes32 is not defined')
            }
            if (bytes32.startsWith('0x')) bytes32 = bytes32.slice(2)
            // new CID(1, 'raw', buffer.Buffer('12206e6ff7950a36187a801613426e858dce686cd7d7e3c0fc42ee0330072d245c95', 'hex'))
            const cid = new CID(1, 'raw', buffer.Buffer('1220' + bytes32, 'hex'))
            // Returns a base encodec string of the CID. Defaults to base58btc.
            // zb2rhe5P4gXftAwvA4eXQ5HJwsER2owDyS9sKaQRRVQPn93bA
            return cid.toBaseEncodedString()
        }

        function ipfsAdd(data) {
            if (!Buffer.isBuffer(data)) {
                data = Buffer.from(data, 'utf8')
            }
            return ipfs.add(data, { hashAlg: 'sha2-256' }).then(res => ({
                hash: res[0].hash,
                bytes32: hashToBytes32(res[0].hash)
            }))
        }

        function ipfsCat(hash) {
            if (hash && !hash.startsWith('Qm')) {
                // Assuming hash is actually a bytes32
                hash = bytes32ToHash(hash)
            }
            return ipfs.cat(hash).then(file => file.toString('utf8'))
        }

        window.ipfs = {
            add: retryable(ipfsAdd),
            cat: retryable(ipfsCat)
        }

        window.ipfsUtils = {
            bytes32ToHash,
            hashToBytes32
        }

        // Import contract data:
        // const { kovSwtToken, hashtagList, simpleDeal } = window.contractsData;

    }());
</script>