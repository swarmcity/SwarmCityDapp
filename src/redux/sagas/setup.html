<script src="../../../node_modules/redux-saga/dist/redux-saga.js"></script>
<script src="../../../node_modules/ethjs/dist/ethjs.min.js"></script>
<script src="../../../node_modules/ipfs-api/dist/index.min.js"></script>
<script src="./bs58.js"></script>
<script src="./Buffer.js"></script>
<script src="../../web3/web3.min.js"></script>
<script src="../contractsData.js"></script>

<script>
    (function () {
        // Initialize web3Local
        const url = 'wss://kovan.infura.io/ws   '
        // const url = 'ws://159.100.255.71:8546'
        // const url = 'ws://my.kovan.dnp.dappnode.eth:8546'
        window.web3Local = new Web3(url);
        window.web3Mainnet = new Web3('wss://mainnet.infura.io/ws');

        // 159.100.255.71:8546 or 8645

        console.log('Redux-sagas is using web3Local version: ', web3Local.version,'host: ', web3Local.currentProvider)
        console.log('Redux-sagas is using web3Mainnet version: ', web3Mainnet.version,'host: ', web3Mainnet.currentProvider)

        /*
         * Setup IPFS with a simple retry async flow. 
         * It will attempt each function 3 times before returning the error
         * 
        **/
        const ipfs = IpfsApi('localhost', '5001', { protocol: 'http' })
        console.log('Redux-sagas is using ipfs at http://localhost:5001')

        const retryable = (fn, times = 3) => (...args) => new Promise((resolve, reject) => {
            let attempt = 0
            function retryAttempt() {
                fn(...args).then(
                    resolve,
                    e => {
                        if (e && attempt++ < times) setTimeout(retryAttempt, 1000 * Math.random())
                        else reject(e)
                    }
                )
            }
            retryAttempt()
        })

        // Dependencies:
        const bs58 = window.bs58
        const Buffer = window.buffer.Buffer

        // Return bytes32 hex string from base58 encoded ipfs hash,
        // stripping leading 2 bytes from 34 byte IPFS hash
        // Assume IPFS defaults: function:0x12=sha2, size:0x20=256 bits
        // E.g. "QmNSUYVKDSvPUnRLKmuxk9diJ6yS96r1TrAXzjTiBcCLAL" -->
        // "0x017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f231"

        function hashToBytes32(hash) {
            if (!hash) return
            if (!hash.startsWith('Qm')) {
                throw Error('Hash must use sha2-256 hashAlg, and start with \'Qm\'')
            }
            return "0x" + bs58.decode(hash).slice(2).toString('hex')
        }

        // Return base58 encoded ipfs hash from bytes32 hex string,
        // Add our default ipfs values for first 2 bytes:
        // function:0x12=sha2, size:0x20=256 bits
        // and cut off leading "0x"
        // E.g. "0x017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f231"
        // --> "QmNSUYVKDSvPUnRLKmuxk9diJ6yS96r1TrAXzjTiBcCLAL"

        function bytes32ToHash(bytes32) {
            if (!bytes32) {
                throw Error('In ipfs.bytes32ToHash, hash or bytes32 is not defined')
            }
            const hashHex = "1220" + bytes32.slice(2)
            const hashBytes = Buffer.from(hashHex, 'hex');
            const hashStr = bs58.encode(hashBytes)
            return hashStr
        }

        function ipfsAdd(data) {
            if (!Buffer.isBuffer(data)) {
                data = Buffer.from(data, 'utf8')
            }
            return ipfs.add(data, { hashAlg: 'sha2-256' }).then(res => ({
                hash: res[0].hash,
                bytes32: hashToBytes32(res[0].hash)
            }))
        }

        function ipfsCat(hash) {
            console.log("ipfs gets ", hash)
            if (hash && !hash.startsWith('Qm')) {
                // Assuming hash is actually a bytes32
                hash = bytes32ToHash(hash)
                console.log("resolves to ", hash)
            }
            return ipfs.cat(hash).then(file => file.toString('utf8'))
        }

        window.ipfs = {
            add: retryable(ipfsAdd),
            cat: retryable(ipfsCat)
        }

        window.bs58 = {
            bytes32ToHash,
            hashToBytes32
        }

        // Import contract data:
        // const { kovSwtToken, hashtagList, simpleDeal } = window.contractsData;

    }());
</script>