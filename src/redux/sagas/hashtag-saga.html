<link rel="import" href="./handleReplyItem.html">

<script>
    (function () {
        // Items initialized in setup.html
        const { web3Local, ipfs, ReduxSaga, contractsData, bs58 } = window;
        const { selectors } = window.AppStore
        // ReduxSaga methods
        const { effects, eventChannel, delay, END } = ReduxSaga;
        const { call, fork, take, put, takeEvery, all, select } = effects;

        // Import contract data:
        const { kovSwtToken, hashtagList, simpleDeal } = contractsData;

        // Import methods
        const { handleReplyItem } = window;

        /** 
         * Data fetching strategy: 
         * 
         * INITIAL FETCH
         * =============
         * 
         * The following steps will be follow to gather all necessary data.
         * After each step, an event will be fired to progressively update the state.
         * 
         * ENTRYPOINT => 'GET_HASHTAG' action, args: [hashtagAddress]
         * 
         * Step 1. Call contract state: 
         *   - hashtagName() -> hashtagName
         *   - hashtagMetadata() -> hashtagMetadata
         *   - deployBlock() -> deployBlock
         * 
         * Step 2A. Resolve hashtagMetadata with IPFS
         *   - ipfs.cat(hashtagMetadata) -> description
         * 
         * Step 2B. Get hashtag items from past events
         *   - getPastEvents('NewItem') -> itemHash, itemMetadataHash, itemValue, seekerAddr, seekerRep, blockNumber
         * 
         * Step 3B. Call contract state to get item status
         *   - readItem(itemHash) -> status, providerAddress, numberOfReplies
         * 
         * Step 3C. Resolve itemMetadataHash
         *   - ipfs.cat(itemMetadataHash) -> seeker, avatarHash, description, publicKey
         * 
         * 
         * SUBSCRIPTION
         * ============
         * 
         * A subscription to all hashtag items will be activated. 
         * The relevant events to listen are:
         * - NewItem(owner, itemHash, itemMetadataHash, itemValue, hashtagFee, seekerRep)
         *   - Emitted on: newItem
         *   - After receiving: resolve itemMetadataHash
         * - ItemChange(indexed itemHash, newstatus, providerAddress)
         *   - Emitted on: selectReplier, fundItem, payoutItem, cancelItem, disputeItem, resolveItem
         *   - After receiving: -
         * - ReplyItem(indexed itemHash, replyMetadataHash, provider) // provider => providerAddress
         *   - Emitted on: replyItem
         *   - After receiving: resolve replyMetadataHash
         * 
        */


        /**
         * Gets hashtag from the blockchain
         */
        async function getHashtagContractData(hashtagAddress) {
            const hashtagContract = new web3Local.eth.Contract(simpleDeal.abi, hashtagAddress);
            let deployBlock;
            try {
                deployBlock = parseInt(await hashtagContract.methods.deployBlock().call())
            } catch (e) {
                console.log('Error retrieving deployBlock from ' + hashtagAddress, e, e.stack)
            }
            return {
                maintainerAddress: await hashtagContract.methods.payoutAddress().call(),
                hashtagName: await hashtagContract.methods.hashtagName().call(),
                hashtagMetadataHash: await hashtagContract.methods.hashtagMetadataHash().call(),
                hashtagFee: parseInt(await hashtagContract.methods.hashtagFee().call()),
                deployBlock: deployBlock || 8149489,
                address: hashtagAddress,
                hashtagAddress
            }
        }

        async function getPastItems(hashtagAddress, fromBlock) {
            const hashtagContract = new web3Local.eth.Contract(simpleDeal.abi, hashtagAddress);
            const events = await hashtagContract.getPastEvents('NewItem', {
                fromBlock,
                toBlock: 'latest',
            })
            console.log('events', events, 'fromBlock', fromBlock)
            const items = {}
            for (event of events) {
                items[event.returnValues.itemHash] = {
                    blockNumber: event.blockNumber,
                    hashtagFee: event.returnValues.hashtagFee,
                    itemMetadataHash: event.returnValues.itemMetadataHash,
                    itemHash: event.returnValues.itemHash,
                    itemValue: event.returnValues.itemValue,
                    seekerAddress: event.returnValues.owner, // owner => seeker
                    seekerRep: event.returnValues.seekerRep,
                }
            }
            return items;
        }

        async function getBlockTime(blockNumber) {
            try {
                const block = await web3Local.eth.getBlock(blockNumber);
                if (block && block.timestamp) {
                    return parseInt(block.timestamp);
                } else {
                    console.error('Error fetching block ' + blockNumber + ' :', block)
                    return 'error';
                }
            } catch (e) {
                console.error('Error fetching timestamp for block ' + blockNumber, e)
            }
        }

        async function multipleGetBlockTime(items) {
            const itemsTimestamp = {}
            await Promise.all(Object.values(items).map(async (item) => {
                itemsTimestamp[item.itemHash] = {
                    timestamp: await getBlockTime(item.blockNumber)
                }
            }))
            return itemsTimestamp;
        }

        async function getHashtagMetadata(hash) {
            const metadataString = await ipfs.cat(hash)
            let metadata;
            try {
                metadata = JSON.parse(metadataString)
            } catch (e) {
                throw Error('JSON parsing error, string: ' + metadataString)
            }
            return {
                metadata
            }
        }

        function* getHashtag({ hashtag: hashtagAddress }) {
            console.log('GET HASHTAG req', hashtagAddress)
            try {
                // Entrypoint, hashtagAddress
                yield fork(hashtagSubscription, hashtagAddress)

                // Step 1. Call contract state: 
                //   - hashtagName() -> hashtagName
                //   - hashtagMetadata() -> hashtagMetadata
                //   - deployBlock() -> deployBlock
                const hashtagContractData = yield call(getHashtagContractData, hashtagAddress)
                yield put({ type: 'UPDATE_NEWHASHTAG', hashtagAddress, data: hashtagContractData });
                yield put({ type: 'ADD_VISITED_HASHTAG', hashtag: hashtagContractData })

                // Step 2A. Resolve hashtagMetadata with IPFS
                //   - ipfs.cat(hashtagMetadata) -> description
                try {
                    const hashtagMetadata = yield call(getHashtagMetadata, hashtagContractData.hashtagMetadataHash)
                    //const res = yield call(catIpfsMetadata, hashtagContractData.hashtagMetadataHash)
                    //console.log('flurkello res: ', hashtagContractData.hashtagMetadataHash);
                    yield put({ type: 'UPDATE_NEWHASHTAG', hashtagAddress, data: hashtagMetadata });
                } catch (e) {
                    console.error('Error fetching hashtag metadata of ' + hashtagAddress, e);
                }

                // Step 2B. Get hashtag items from past events
                //   - getPastEvents('NewItem') -> itemHash, itemMetadataHash, itemValue, seekerAddr, seekerRep, blockNumber
                const items = yield call(getPastItems, hashtagAddress, hashtagContractData.deployBlock)
                yield put({ type: 'UPDATE_NEWHASHTAG', hashtagAddress, data: { items } });

                const itemsTimestamp = yield call(multipleGetBlockTime, items)
                // This fetch happens really quick and would generate too many re-renders at once.
                yield put({ type: 'UPDATE_NEWHASHTAG', hashtagAddress, data: { items: itemsTimestamp } });

                // Step 3B. Call contract state to get item status
                //   - readItem(itemHash) -> status, providerAddress, numberOfReplies
                // 
                // Step 3C. Resolve itemMetadataHash
                //   - ipfs.cat(itemMetadataHash) -> seeker, avatarHash, description, publicKey

                // Pass the contract object to avoid many concurrent initializations
                const hashtagContract = new web3Local.eth.Contract(simpleDeal.abi, hashtagAddress);
                yield all(Object.values(items).map(item => all([
                    call(getItemState, item, hashtagAddress, hashtagContract),
                    call(getItemMetadata, item, hashtagAddress),
                    call(getItemRepliers, item, hashtagAddress, hashtagContract)
                ])))

                console.log('Finished fetching items!!')

            } catch (e) {
                console.error(e);
            }
        }

        function readItemData(itemHash, hashtagContract) {
            return hashtagContract.methods.readItemData(itemHash).call();
        }

        function* getItemState(item, hashtagAddress, hashtagContract) {
            const { itemHash } = item;
            try {
                const res = yield call(readItemData, itemHash, hashtagContract)
                yield put({
                    type: 'UPDATE_ITEM', hashtagAddress, itemHash, data: {
                        numberOfReplies: res.numberOfReplies,
                        providerAddress: res.providerAddress,
                        providerRep: res.providerRep,
                        status: res.status,
                    }
                });
                yield call(openChat, { hashtagAddress, itemHash, itemStatus: res.status, providerAddress: res.providerAddress, seekerAddress: item.seekerAddress })
            } catch (e) {
                console.log('Error calling readItem() for item: ' + itemHash + ' in hashtag: ' + hashtagAddress, e);
            }
        }

        function catIpfsMetadata(hash) {
            return ipfs.cat(hash).then(JSON.parse)
        }

        function* getItemMetadata(item, hashtagAddress) {
            try {
                const { itemMetadataHash: hash, itemHash } = item;
                const res = yield call(catIpfsMetadata, hash)
                yield put({
                    type: 'UPDATE_ITEM', hashtagAddress, itemHash, data: {
                        seekerAvatarHash: res.avatar || res.avatarHash,
                        description: res.description,
                        seekerPublicKey: res.publicKeySeeker,
                        seekerUsername: res.username,
                    }
                });
            } catch (e) {
                console.log('Error getting IPFS metadata for item: ' + item.itemHash + ' in hashtag: ' + hashtagAddress, e);
            }
        }

        function callGetItemRepliers(itemHash, hashtagContract) {
            return hashtagContract.methods.getItemRepliers(itemHash).call();
        }

        function* getItemRepliers(item, hashtagAddress, hashtagContract) {
            const { itemHash } = item;
            try {
                const res = yield call(callGetItemRepliers, itemHash, hashtagContract)
                yield put({
                    type: 'UPDATE_ITEM', hashtagAddress, itemHash, data: {
                        repliers: res,
                    }
                });
            } catch (e) {
                console.log('Error calling getItemRepliers() for item: ' + itemHash + ' in hashtag: ' + hashtagAddress, e);
            }
        }

        function* openChat({ hashtagAddress, itemHash, itemStatus, providerAddress, seekerAddress }) {
            // ##### 
            // Check if the item may contain a conversation that you are interested in
            // First, the item must be in Funded or Disputed state.
            const getHashtag = (state) => state.hashtags[hashtagAddress] || {}
            const getItem = (state) => ((getHashtag(state)).items || {})[itemHash] || {}

            if (itemStatus == 1 || itemStatus == 3) {
                // If the seeker or the provider are not provided, fetch them from the current state
                if (!seekerAddress) seekerAddress = yield select(getItem).seekerAddress
                if (!providerAddress) providerAddress = yield select(getItem).providerAddress
                const maintainerAddress = yield select(getHashtag).maintainerAddress
                const yourAddress = yield select(selectors.address)
                if (!yourAddress) {
                    console.warn('Warning, yourAddress is not defined at the moment of checking if you belong in a chat. Possible race condition.')
                }
                // Check if the user is either the seeker or the provider
                if (providerAddress == yourAddress || seekerAddress == yourAddress || (itemStatus == 3 && yourAddress == maintainerAddress)) {
                    window.dispatchEvent(new CustomEvent('openChat', {
                        detail: { itemHash, yourAddress }
                    }));
                }
            }
        }

        /** 
         * Data fetching strategy: 
         * 
         * SUBSCRIPTION
         * ============
         * 
         * A subscription to all hashtag items will be activated. 
         * The relevant events to listen are:
         * - NewItem(owner, itemHash, itemMetadataHash, itemValue, hashtagFee, seekerRep)
         *   - Emitted on: newItem
         *   - After receiving: resolve itemMetadataHash
         * - ItemChange(indexed itemHash, newstatus, providerAddress)
         *   - Emitted on: selectReplier, fundItem, payoutItem, cancelItem, disputeItem, resolveItem
         *   - After receiving: -
         * - ReplyItem(indexed itemHash, replyMetadataHash, provider) // provider => providerAddress
         *   - Emitted on: replyItem
         *   - After receiving: resolve replyMetadataHash
         * 
        */


        function createHashtagSubscriptionChannel(hashtagAddress) {
            const hashtagContract = new web3Local.eth.Contract(simpleDeal.abi, hashtagAddress);
            return eventChannel(emitter => {
                // Unique place to subscribe to all hashtag relevant events
                //  - NewItem(owner, itemHash, itemMetadataHash, itemValue, hashtagFee, seekerRep)
                //  - ItemChange(indexed itemHash, newstatus, providerAddress)
                //  - ReplyItem(indexed itemHash, replyMetadataHash, provider) // provider => providerAddress
                const events = ['NewItem', 'ItemChange', 'ReplyItem']
                const subscribeInstances = events.map(eventName => {
                    try {
                        return hashtagContract.events[eventName]((err, event) => {
                            if (err) console.error('Error receiving event', err)
                            else emitter(event)
                        })
                    } catch (e) {
                        console.error('Error creating subscription to NewItem in ' + hashtagAddress)
                    }
                })

                window.addEventListener('cancel-sub', () => {
                    emitter(END)
                });

                const unsubscribeFunction = () => {
                    subscribeInstances.forEach(instance => {
                        // Ensure that the instance exists
                        if (instance) instance.unsubscribe((err) => {
                            if (err) console.error('Error unsubscribing from hashtag', err)
                            else console.log('Successfully unsubscribed')
                        });
                    });
                }
                // The subscriber must return an unsubscribe function
                return unsubscribeFunction;
            })
        }

        function* handleNewItem(event, hashtagAddress, newEvent = false) {
            // NewItem(owner, itemHash, itemMetadataHash, itemValue, hashtagFee, seekerRep)
            // Step 1. Store the item info
            console.log('Handling NewItem', event)
            const item = {
                blockNumber: event.blockNumber,
                hashtagFee: event.returnValues.hashtagFee,
                itemMetadataHash: event.returnValues.itemMetadataHash,
                itemHash: event.returnValues.itemHash,
                itemValue: event.returnValues.itemValue,
                seekerAddress: event.returnValues.owner, // owner => seeker
                seekerRep: event.returnValues.seekerRep,
                status: 0,
            }
            const { itemHash, itemMetadataHash } = event.returnValues
            yield put({ type: 'UPDATE_ITEM', hashtagAddress, itemHash, data: item });

            // Step 2. Resolve its metadata
            yield fork(getItemMetadata, item, hashtagAddress)

            // Step 3. Get the timestamp
            const timestamp = newEvent
                ? Math.floor(Date.now() / 1000)
                : yield call(getBlockTime, event.blockNumber)
            yield put({ type: 'UPDATE_ITEM', hashtagAddress, itemHash, data: { timestamp } });
        }

        function* handleItemChange(event, hashtagAddress) {
            // ItemChange(indexed itemHash, newstatus, providerAddress)
            // Step 1. Store the item info
            console.log('Handling ItemChange', event)
            const { itemHash, newstatus, providerAddress } = event.returnValues

            if (newstatus == '5') {
                yield put({
                    type: 'UPDATE_ITEM', hashtagAddress, itemHash, data: {
                        status: newstatus,
                        providerAddress,
                    }
                });
            } else {
                yield put({
                    type: 'UPDATE_ITEM', hashtagAddress, itemHash, data: {
                        status: newstatus,
                        providerAddress,
                    }
                });

            }
            yield call(openChat, { hashtagAddress, itemHash, itemStatus: newstatus, providerAddress })
        }


        function* hashtagSubscription(hashtagAddress) {
            try {
                const hashtagSubscriptionChannel = yield call(createHashtagSubscriptionChannel, hashtagAddress)
                while (true) {
                    // take(END) will cause the saga to terminate by jumping to the finally block
                    let event = yield take(hashtagSubscriptionChannel)
                    // Unique place to subscribe to all hashtag relevant events
                    //  - NewItem(owner, itemHash, itemMetadataHash, itemValue, hashtagFee, seekerRep)
                    //  - ItemChange(indexed itemHash, newstatus, providerAddress)
                    //  - ReplyItem(indexed itemHash, replyMetadataHash, provider)
                    switch (event.event) {
                        case 'NewItem':
                            yield fork(handleNewItem, event, hashtagAddress, true)
                            break;
                        case 'ItemChange':
                            yield fork(handleItemChange, event, hashtagAddress)
                            break;
                        case 'ReplyItem':
                            yield fork(handleReplyItem, event, true)
                            break;
                        default:
                            console.error('Received unknown event ' + event.event, event)
                    }
                }
            } finally {
                console.log('hashtag ' + hashtagAddress + ' subscription terminated')
            }
        }


        /*
         * redux-saga root function, which is responsible to call the correct workers
         */
        function* rootSaga() {
            yield all([
                yield takeEvery('GET_HASHTAG', getHashtag),
            ]);
        }

        if (!window.AppStore) window.AppStore = {}
        if (!window.AppStore.sagas) window.AppStore.sagas = []
        window.AppStore.sagas.push(rootSaga)
    }());
</script>