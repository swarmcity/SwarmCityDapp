<script>
    (function () {
        // Items initialized in setup.html
        const { web3Local, ipfs, ReduxSaga, contractsData } = window;
        // ReduxSaga methods
        const { effects, eventChannel, delay } = ReduxSaga;
        const { call, fork, take, put, takeEvery, all, select } = effects;

        // Import contract data:
        const { kovSwtToken, hashtagList, simpleDeal } = contractsData;


        /**
         * Action creators
         */
        function updateReply(hashtagAddress, itemHash, providerAddress, data) {
            return {
                type: 'UPDATE_ITEM', hashtagAddress, itemHash, data: {
                    replies: {
                        [providerAddress]: data
                    }
                }
            }
        }


        function* handleReplyItem(event, newEvent = false) {
            try {
                // ReplyItem(indexed itemHash, replyMetadataHash, provider) // provider => providerAddress
                // Step 1. Store the reply info
                console.log('Handling ReplyEvent', event)
                const { itemHash, replyMetadataHash, provider: providerAddress } = event.returnValues
                // Protection against calling toLowerCase() on undefined variables
                const hashtagAddress = event.address ? event.address.toLowerCase() : event.address
                const reply = {
                    blockNumber: event.blockNumber,
                    providerAddress,
                    replyMetadataHash,
                }
                // Create a shortcut to the action object
                const updateThisReply = (data) => updateReply(hashtagAddress, itemHash, providerAddress, data)

                yield put(updateThisReply(reply))

                yield all([
                    call(function* () {
                        // Step 2A. Resolve its metadata
                        try {
                            const replyMetadataObj = yield call(catIpfsMetadata, replyMetadataHash)
                            yield put(updateThisReply(replyMetadataObj))
                        } catch (e) {
                            console.error(`Error fetching replyMetada of itemHash: ${itemHash}`, e)
                        }
                    }),
                    call(function* () {
                        // Step 2B. Get the timestamp
                        try {
                            // Step 3. Get the timestamp
                            const timestamp = newEvent
                                ? Math.floor(Date.now() / 1000)
                                : yield call(getBlockTime, event.blockNumber)
                            yield put(updateThisReply({ timestamp }))
                        } catch (e) {
                            console.error(`Error fetching reply's timestamp of itemHash: ${itemHash}`, e)
                        }
                    }),
                    call(function* () {
                        // Step 2C. Get the providers reputation
                        try {
                            const providerRep = yield call(fetchProviderReputation, hashtagAddress, providerAddress)
                            yield put(updateThisReply({ providerRep }))
                        } catch (e) {
                            console.error(`Error fetching reply's providerRep of itemHash: ${itemHash}`, e)
                        }
                    })
                ])

                // Notifications
                // At this point all the item info is checked.
                item = yield select(state => (state.hashtags[hashtagAddress] || {}).items[itemHash]);
                // 1. Check if you are involved
                if (yield call(youAreInvolvedInThisItem, item)) {
                    yield put({ type: "CHECK_INVOLVED_ITEM", newItem: item });
                }
            } catch (e) {
                console.error(`Error handling reply of itemHash: ${itemHash}`, e)
            }
        }

        /**
         * @param {Object} item must be an object with this properites: {
         *    numberOfReplies,
         *    providerAddress,
         *    status,
         *    seekerAddress,
         *    description,
         * }
         * @returns {Bool} true if you are involved in this item
         */
        function* youAreInvolvedInThisItem(item) {
            const yourAddress = yield select(selectors.address);
            return (
                item.providerAddress === yourAddress ||
                item.seekerAddress === yourAddress ||
                (item.repliers || []).includes(yourAddress)
            )
        }

        function catIpfsMetadata(hash) {
            return ipfs.cat(hash).then(JSON.parse)
        }

        async function getBlockTime(blockNumber) {
            try {
                const block = await web3Local.eth.getBlock(blockNumber);
                if (block && block.timestamp) {
                    return parseInt(block.timestamp);
                } else {
                    console.error('Error fetching block ' + blockNumber + ' :', block)
                    return 'timestamp error';
                }
            } catch (e) {
                console.error('Error fetching timestamp for block ' + blockNumber, e)
            }
        }

        async function fetchProviderReputation(hashtagAddress, providerAddress) {
            // ### The reputation is a token balance that should be fetch from the blockchain
            // - Follow the procedure (not implemented, use web3Local)
            // HashtagAddress = smart contract simple deal
            // => Get the providerRep smart contract address
            // => Do balanceOf(replier.address)
            const hashtagContract = new web3Local.eth.Contract(
                simpleDeal.abi,
                hashtagAddress
            );

            if (!hashtagContract.methods.ProviderRep) {
                throw Error('Incorrect contrat ABI, ProviderRep method not found');
            }
            // eslint-disable-next-line new-cap
            const providerRepContractAddress = await hashtagContract.methods.ProviderRep().call()
            if (!providerRepContractAddress) {
                throw Error('Missing providerRepContractAddress: ' + providerRepContractAddress);
            }
            const providerRepContract = new web3Local.eth.Contract(
                kovSwtToken.abi,
                providerRepContractAddress
            );
            return await providerRepContract.methods.balanceOf(providerAddress).call();
        }


        window.handleReplyItem = handleReplyItem;
    }());
</script>