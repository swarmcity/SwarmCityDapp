<script src="../node_modules/redux/dist/redux.min.js"></script>
<script src="./defaultAvatar.js"></script>
<link rel="import" href="../bower_components/polymer-redux/polymer-redux.html">
<script>
    let publicKey;
    let avatar;
    let username;
    let storage = JSON.parse(localStorage.getItem('SwarmCity'));

    if (storage && storage.keyStore && storage.keyStore.address) {
        publicKey = storage.keyStore.address;
    } else {
        publicKey = '';
    }
    if (storage && storage.user && storage.user.username) {
        username = storage.user.username;
    } else {
        username = '';
    }
    if (storage && storage.user && storage.user.avatar) {
        avatar = storage.user.avatar;
    } else {
        avatar = defaultAvatar; // eslint-disable-line
    }

    let initialState = {
        gasPrice: 21e9,
        username: username,
        avatar: avatar,
        broadcast: null,
        shortCode: null,
        toAddress: null,
        toUserName: null,
        amountToSend: 0,
        confirmedTx: [],
        shownTx: [],
        usingShortCode: false,
        language: 'en',
        fx: {
            priceBtc: 1,
            priceEur: 1,
            priceUsd: 1,
        },
        balance: {
            swt: {
                balanceSwt: 0,
                balanceUsd: 0,
            },
        },
        hashtags: [{
            hashtagName: 'Settler',
            hashtagAddress: '0x3a1a67501b75fbc2d0784e91ea6cafef6455a066',
            stats: { 'paidNoConflict': 0, 'resolved': 0, 'seekers': 0, 'providers': 0 },
            hashtagFee: 600000000000000000,

        }, {
            hashtagName: 'ScCommShare',
            hashtagAddress: '0x9Ffe60f2A9153BD0a5bb9446A06286B67FADf1bE',
            stats: { 'paidNoConflict': 0, 'resolved': 0, 'seekers': 0, 'providers': 0 },
            hashtagFee: 600000000000000000,
        }, {
            hashtagName: 'SwarmCitySwag',
            hashtagAddress: '0xb722099bb19d76fDa05Ca0551223c1dF34026353',
            stats: { 'paidNoConflict': 0, 'resolved': 0, 'seekers': 0, 'providers': 0 },
            hashtagFee: 600000000000000000,
        },
        ],
        publicKey: publicKey,
        nonce: -1,
    };

    /**
     * Recalculate balances & formatting of
     *
     * @param      {Object}  balance  The balance object
     * @param      {Object}  fx       The fx object ( exchange rates )
     * @return     {Object}  decorated balance object
     */
    function updateBalance(balance, fx) {
        if (balance &&
            balance.swt &&
            balance.swt.balance &&
            fx &&
            fx.priceEur &&
            fx.priceBtc &&
            fx.priceUsd) {
            balance.swt.balanceSwt = (balance.swt.balance / 1e18).toFixed(2);
            balance.swt.balanceEur = (balance.swt.balance / 1e18 * fx.priceEur).toFixed(2);
            balance.swt.balanceBtc = (balance.swt.balance / 1e18 * fx.priceBtc);
            balance.swt.balanceUsd = (balance.swt.balance / 1e18 * fx.priceUsd).toFixed(2);
        }
        if (balance &&
            balance.eth &&
            balance.eth.balance) {
            balance.eth.balanceEth = (balance.eth.balance / 1e18);
        }
        return balance;
    }

    /**
     * safely parse a string to Number. Independent of locale ( , or . )
     *
     * @param      {string}  input   The input
     * @return     {Number}  The floating point value - or 0 if cannot parse
     */
    function _parseFloat(input) {
        if (input && typeof input === 'string') {
            let parsed = Number.parseFloat(input.replace(',', '.'));
            if (Number.isNaN(parsed)) {
                return 0;
            }
            return parsed;
        } else {
            return 0;
        }
    }

    let reducer = function (state, action) {
        if (!state) {
            return initialState;
        }
        switch (action.type) {
            case 'SHORTCODE': {
                let shortCode = state.shortCode;
                shortCode = action.shortCode;
                return Object.assign({}, state, {
                    shortCode: shortCode,
                });
            }
            case 'USINGSHORTCODE': {
                let usingShortCode = state.usingShortCode;
                usingShortCode = action.usingShortCode;
                return Object.assign({}, state, {
                    usingShortCode: usingShortCode,
                });
            }
            case 'BALANCE': {
                let balance = state.balance;
                balance = action.balance;
                return Object.assign({}, state, {
                    balance: updateBalance(balance, state.fx),
                });
            }
            case 'FX': {
                let fx = state.fx;
                fx = action.fx;

                // convert strings to Float
                if (fx.priceBtc) fx.priceBtc = _parseFloat(fx.priceBtc);
                if (fx.priceEur) fx.priceEur = _parseFloat(fx.priceEur);
                if (fx.priceUsd) fx.priceUsd = _parseFloat(fx.priceUsd);

                return Object.assign({}, state, {
                    fx: fx,
                    balance: updateBalance(state.balance, fx),
                });
            }
            case 'HASHTAGS': {
                let hashtags = state.hashtags;
                hashtags = action.hashtags;
                return Object.assign({}, state, {
                    hashtags: hashtags,
                });
            }
            case 'LANGUAGE': {
                let language = state.language;
                language = action.language;
                return Object.assign({}, state, {
                    language: language,
                });
            }
            case 'ITEMCOLLECTION': {
                let itemCollection = state.itemCollection;
                itemCollection = action.itemCollection;
                return Object.assign({}, state, {
                    itemCollection: itemCollection,
                });
            }
            case 'LOCATION': {
                let location = state.location;
                location = action.location;
                return Object.assign({}, state, {
                    location: location,
                });
            }
            case 'PUBLICKEY': {
                let publicKey = state.publicKey;
                publicKey = action.publicKey;
                return Object.assign({}, state, {
                    publicKey: publicKey,
                });
            }
            case 'GASPRICE': {
                let gasPrice = state.gasPrice;
                gasPrice = _parseFloat(action.gasPrice);
                return Object.assign({}, state, {
                    gasPrice: gasPrice,
                });
            }
            case 'NONCE': {
                let nonce = state.nonce;
                nonce = action.nonce;
                return Object.assign({}, state, {
                    nonce: nonce,
                });
            }
            // This is the shortCode we want a public key for
            case 'REQTOKEY': {
                let reqtokey = state.reqtokey;
                reqtokey = action.reqtokey;
                return Object.assign({}, state, {
                    reqtokey: reqtokey,
                });
            }
            // This is the translation of the shortCode to a public key
            case 'TOKEY': {
                let tokey = state.tokey;
                tokey = action.tokey;
                return Object.assign({}, state, {
                    tokey: tokey,
                });
            }
            // This is the signed transaction to broadcast
            case 'BROADCAST': {
                let broadcast = state.broadcast;
                broadcast = action.broadcast;
                return Object.assign({}, state, {
                    broadcast: broadcast,
                });
            }
            // This is the txHash of the broadcasted transaction
            case 'TXHASH': {
                let txHash = state.txHash;
                txHash = action.txHash;
                return Object.assign({}, state, {
                    txHash: txHash,
                });
            }
            // This is the array containing all past transactions on user's publicKey
            case 'CONFIRMEDTX': {
                let confirmedTx = state.confirmedTx;
                confirmedTx = action.confirmedTx;
                return Object.assign({}, state, {
                    confirmedTx: confirmedTx,
                });
            }
            // This is the array containing all past transactions on user's publicKey
            case 'SHOWNTX': {
                let shownTx = state.shownTx;
                shownTx = action.shownTx;
                return Object.assign({}, state, {
                    shownTx: shownTx,
                });
            }
            // An array containing all reputation earned
            case 'REPUTATION': {
                let reputation = state.reputation;
                reputation = action.reputation;
                return Object.assign({}, state, {
                    reputation: reputation,
                });
            }
            // A base64 string containing the user avatar
            case 'AVATAR': {
                let avatar = state.avatar;
                avatar = action.avatar;
                return Object.assign({}, state, {
                    avatar: avatar,
                });
            }
            // An ipfsHash resolving to the user's base64 avatar
            case 'AVATARHASH': {
                let avatarHash = state.avatarHash;
                avatarHash = action.avatarHash;
                return Object.assign({}, state, {
                    avatarHash: avatarHash,
                });
            }
            // A string containing the username
            case 'USERNAME': {
                let username = state.username;
                username = action.username;
                return Object.assign({}, state, {
                    username: username,
                });
            }
            // A string containing the ipfs hash of an image
            case 'REQIPFS': {
                let reqipfs = state.reqipfs;
                reqipfs = action.reqipfs;
                return Object.assign({}, state, {
                    reqipfs: reqipfs,
                });
            }
            // A string containing an ipfs hash to resolve
            case 'IPFSHASH': {
                let ipfsHash = state.ipfsHash;
                ipfsHash = action.ipfsHash;
                return Object.assign({}, state, {
                    ipfsHash: ipfsHash,
                });
            }
            // A string containing the address of the recipient
            case 'TOADDRESS': {
                let toAddress = state.toAddress;
                toAddress = action.toAddress;
                return Object.assign({}, state, {
                    toAddress: toAddress,
                });
            }
            // A string containing the username of the recipient
            case 'TOUSERNAME': {
                let toUserName = state.toUserName;
                toUserName = action.toUserName;
                return Object.assign({}, state, {
                    toUserName: toUserName,
                });
            }
            // A string containing the amount to send
            case 'AMOUNTTOSEND': {
                let amountToSend = state.amountToSend;
                amountToSend = action.amountToSend;
                return Object.assign({}, state, {
                    amountToSend: amountToSend,
                });
            }
            // A string containing the budget for a new request
            case 'ITEMBUDGET': {
                let itemBudget = state.itemBudget;
                itemBudget = action.itemBudget;
                return Object.assign({}, state, {
                    itemBudget: itemBudget,
                });
            }
            // A string containing the description for a new request
            case 'ITEMDESCRIPTION': {
                let itemDescription = state.itemDescription;
                itemDescription = action.itemDescription;
                return Object.assign({}, state, {
                    itemDescription: itemDescription,
                });
            }
            // A string containing the hashtag fee
            case 'ITEMFEE': {
                let itemFee = state.itemFee;
                itemFee = action.itemFee;
                return Object.assign({}, state, {
                    itemFee: itemFee,
                });
            }
            // A string containing the hashtag fee
            case 'ITEMTOIPFS': {
                let itemToIpfs = state.itemToIpfs;
                itemToIpfs = action.itemToIpfs;
                return Object.assign({}, state, {
                    itemToIpfs: itemToIpfs,
                });
            }
            // The IPFS hash with the new request item data
            case 'ITEMDATAHASH': {
                let itemDataHash = state.itemDataHash;
                itemDataHash = action.itemDataHash;
                return Object.assign({}, state, {
                    itemDataHash: itemDataHash,
                });
            }
            // A string containing the hashtag fee
            case 'REPLYTOIPFS': {
                let replyToIpfs = state.replyToIpfs;
                replyToIpfs = action.replyToIpfs;
                return Object.assign({}, state, {
                    replyToIpfs: replyToIpfs,
                });
            }
            // A string containing the hashtag fee
            case 'REPLYDATAHASH': {
                let replyDataHash = state.replyDataHash;
                replyDataHash = action.replyDataHash;
                return Object.assign({}, state, {
                    replyDataHash: replyDataHash,
                });
            }
            // A signed tx to send
            case 'SENDSIGNEDTX': {
                let sendSignedTx = state.sendSignedTx;
                sendSignedTx = action.sendSignedTx;
                return Object.assign({}, state, {
                    sendSignedTx: sendSignedTx,
                });
            }
            // Hashtag will set the current hashtag we're on
            case 'HASHTAG': {
                let hashtag = state.hashtag;
                hashtag = action.hashtag;
                return Object.assign({}, state, {
                    hashtag: hashtag,
                });
            }
            // HashtagItem will set the current hashtag item we're on
            case 'HASHTAGITEM': {
                let hashtagItem = state.hashtagItem;
                hashtagItem = action.hashtagItem;
                return Object.assign({}, state, {
                    hashtagItem: hashtagItem,
                });
            }
            // GeoHash is the full geohash of the user's location
            case 'GEOHASH': {
                let geohash = state.geohash;
                geohash = action.geohash;
                return Object.assign({}, state, {
                    geohash: geohash,
                });
            }
            // GeoHash is the new item's geohash
            case 'ITEMGEOHASH': {
                let itemGeohash = state.itemGeohash;
                itemGeohash = action.itemGeohash;
                return Object.assign({}, state, {
                    itemGeohash: itemGeohash,
                });
            }
            // userReputation is the reputation of a certain user
            case 'USERREPUTATION': {
                let userReputation = state.userReputation;
                userReputation = action.userReputation;
                return Object.assign({}, state, {
                    userReputation: userReputation,
                });
            }
            // chatHistory is the object containing the full chat history
            case 'CHATHISTORY': {
                let chatHistory = state.chatHistory;
                chatHistory = action.chatHistory;
                return Object.assign({}, state, {
                    chatHistory: chatHistory,
                });
            }
            // the newChatMessage object contains a new chat message for a chat subscription
            case 'NEWCHATMESSAGE': {
                let newChatMessage = state.newChatMessage;
                newChatMessage = action.newChatMessage;
                return Object.assign({}, state, {
                    newChatMessage: newChatMessage,
                });
            }
        }
    };
    const store = Redux.createStore(reducer, /* preloadedState, */
        window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
    );
    ReduxMixin = new PolymerRedux(store);
</script>