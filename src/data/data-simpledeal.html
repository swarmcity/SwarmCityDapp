<link rel="import" href="../../bower_components/polymer/polymer-element.html">

<dom-module id="data-simpledeal">
    <script>
        // Import libraries
        const Tx = webpack.EthereumTx
        const Buffer = webpack.Buffer.Buffer
        const _web3 = window.web3Local
        const sha3 = webpack.sha3
        const ipfs = window.ipfs

        const {
            swtToken,
            hashtagList,
            simpleDeal
        } = contractsData;

        // Define async methods, because 
        // oh hi classes can u support async/await plz tkns
        async function createNewItemAsync({ seeker, item, hashtag }) {

            // 0. Upload to IPFS
            const metadataHash = await ipfs.add(JSON.stringify({
                username: seeker.username,
                avatarHash: localStorage.getItem('avatarHash'),
                description: item.description,
                location: item.location,
                publicKeySeeker: webpack
                    .privateToPublic(new Buffer(seeker.privateKey, 'hex'))
                    .toString('hex')
            }))


            // const itemBudgetWei = _web3.utils.toWei(String(item.budget), 'ether')
            const itemBudgetWei = item.budget * 1e18;
            const totalSum = parseInt(itemBudgetWei) + parseInt(hashtag.fee / 2);

            // 1. Encode the newItem method to be sent through ApproveAndCall
            const simpleDealContract = new _web3.eth.Contract(simpleDeal.abi, hashtag.address);
            const rawNewItem = simpleDealContract.methods.newItem(
                item.hash,
                itemBudgetWei,
                metadataHash.bytes32
            ).encodeABI();
            const tokenContract = new _web3.eth.Contract(swtToken.abi, hashtag.tokenAddress);
            const rawApproveAndCall = tokenContract.methods.approveAndCall(
                hashtag.address, // spender
                totalSum, // totalSum
                rawNewItem, // next call data
            ).encodeABI();

            // 2. Get user's nonce
            const nonce = await _web3.eth.getTransactionCount(seeker.address)

            // 3. Generate tx object, sign and serialize
            const tx = new Tx({
                nonce: _web3.utils.toHex(nonce),
                from: seeker.address,
                gasPrice: 1000000000,
                gasLimit: 3000000,
                to: hashtag.tokenAddress,
                data: rawApproveAndCall,
                chainId: 42,
            });
            tx.sign(new Buffer(seeker.privateKey, 'hex'));
            const serializedTx = tx.serialize();

            // 4. Send transaction, await receipt. 
            // Extra line for clarity
            const hash = await sendSignedTransaction('0x' + serializedTx.toString('hex'))
            return hash
        }


        /**
         * to hex
         * @param {String} dec - The data to convert
         * @return {Object} - the input data in hex format
         */
        function _toHex(dec) {
            let hex = Number(dec).toString(16);
            let result = '000000'.substr(0, 6 - hex.length) + hex;
            return '0x' + result;
        }

        function sendSignedTransaction(tx) {
            return new Promise((resolve, reject) => {
                let _hash;
                _web3.eth.sendSignedTransaction(tx)
                    .once('transactionHash', (hash) => {
                        resolve(hash)
                        _hash = hash
                    })
                    .on('receipt', (receipt) => {
                        console.log('received receipt for txHash: ' + hash, receipt);
                    })
                    .on('error', (err, receipt) => {
                        if (err.message &&
                            err.message.startsWith('Failed to check for transaction receipt')
                        ) {
                            console.log('Another complaint about the receipt ignored.');
                        } else {
                            if (receipt) {
                                console.error('We might be out of Gas: %j', receipt);
                            } else {
                                console.error(err);
                            }
                            reject(new Error('Transaction error: ' + err));
                        }
                    });
            })
        }

        class DataSimpledeal extends Polymer.Element {
            static get is() {
                return 'data-simpledeal';
            }

            /**
             * Create a new hashtag item
             */
            createNewItem(args) {
                return createNewItemAsync(args)
            }

            /**
             * Create a new hashtag item
             * @param {String} itemHash - The itemHash in Hex (with prefix)
             * @param {Number} weiAmount - The item value in wei
             * @param {String} ipfsHash - The item's metadata ipfs hash
             * @param {String} contractAddress - The hashtag's address
             * @param {Object} abi - The hashtag contract's abi
             * @return {Object} - The Raw new item tx data
             */
            rawNewItem(itemHash, weiAmount, ipfsHash, contractAddress, abi) {
                const simpleDealContract = new webpack.Contract(
                    abi,
                    contractAddress
                );
                let rawNewItem = simpleDealContract.methods.newItem(
                    itemHash,
                    weiAmount,
                    ipfsHash
                ).encodeABI();
            }

            /**
             * Reply to an item
             * @param {String} itemHash - The itemHash in Hex (with prefix)
             * @param {String} ipfsHash - The reply data ipfs hash
             * @param {String} contractAddress - The hashtag's address
             * @param {Object} abi - The hashtag contract's abi
             * @return {Object} - The Raw reply tx data
             */
            rawReplyItem(itemHash, ipfsHash, contractAddress, abi) {
                return new Promise((resolve) => {
                    const simpleDealContract = new webpack.Contract(
                        abi,
                        contractAddress
                    );
                    let rawReplyItem = simpleDealContract.methods.replyItem(
                        itemHash,
                        ipfsHash
                    ).encodeABI();
                    resolve(rawReplyItem);
                });
            }

            /**
             * As seeker, select a replier to your item as potential provider
             * @param {String} itemHash - The itemHash in Hex (with prefix)
             * @param {String} replierAddress - The replier's address
             * @param {String} contractAddress - The hashtag's address
             * @param {Object} abi - The hashtag contract's abi
             * @return {Object} - The Raw reply tx data
             */
            rawSelectReplier(itemHash, replierAddress, contractAddress, abi) {
                return new Promise((resolve) => {
                    const simpleDealContract = new webpack.Contract(
                        abi,
                        contractAddress
                    );
                    let rawSelectReplier = simpleDealContract.methods.selectReplier(
                        itemHash,
                        replierAddress
                    ).encodeABI();
                    resolve(rawSelectReplier);
                });
            }

            /**
             * Fund a hashtag item
             * @param {String} itemHash - The itemHash of the item
             * @param {String} contractAddress - The hashtag's address
             * @param {Object} abi - The hashtag contract's abi
             * @return {Object} - The Raw new item tx data
             */
            rawFundItem(itemHash, contractAddress, abi) {
                return new Promise((resolve) => {
                    const simpleDealContract = new webpack.Contract(
                        abi,
                        contractAddress
                    );
                    let rawFundItem = simpleDealContract.methods.fundItem(
                        itemHash
                    ).encodeABI();
                    resolve(rawFundItem);
                });
            }

            /**
             * Pay the provider the full sum
             * @param {String} itemHash - The itemHash in Hex (with prefix)
             * @param {String} contractAddress - The hashtag's address
             * @param {Object} abi - The hashtag contract's abi
             * @return {Object} - The Raw payout item tx data
             */
            rawPayoutItem(itemHash, contractAddress, abi) {
                return new Promise((resolve) => {
                    const simpleDealContract = new webpack.Contract(abi, contractAddress);
                    let rawPayoutItem = simpleDealContract.methods.payoutItem(itemHash).encodeABI();
                    resolve(rawPayoutItem);
                });
            }

            /**
             * Filter the hashtag object to return a formatted list of items the user is involved in
             * @return {items} The array with items the user is involved in
             * @argument {object} hashtag the current hashtag
             * @argument {String} userAddress the user's address
             * @argument {String} involved if true, return the items the user is involved with
             */
            getHashtagItems(hashtag, userAddress, involved) {
                return new Promise((resolve) => {
                    let items = Object.values(hashtag.items)
                        .filter((item) => {
                            let isInvolved = false;
                            if (!item.itemHash) return false;
                            if (item.replies && item.replies[userAddress]) {
                                isInvolved = true;
                            }
                            if (item.seeker.address == userAddress) {
                                isInvolved = true;
                            }
                            // Don't add completed deals to items involved
                            if (item.status && item.status == 2) isInvolved = false;
                            if (involved) {
                                // only return items the user is involved with
                                return isInvolved;
                            } else {
                                // only return items the user is not involved with
                                return !isInvolved;
                            }
                        })
                        .map((item) => {
                            // If missing seeker username, use address
                            item.seeker.username = item.seeker.username || item.seeker.address;
                            // If missing description, use default
                            item.description = item.description || 'Missing description';
                            return item;
                        })
                        .sort((a, b) => {
                            // sort the array by date, newest first
                            return parseInt(b.dateTime) - parseInt(a.dateTime);
                        });
                    resolve(items);
                });
            }
        }
        window.customElements.define(DataSimpledeal.is, DataSimpledeal);
    </script>
</dom-module>